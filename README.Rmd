```{r setup,include=FALSE}
# set the knitr options ... for everyone!
# if you unset this, then vignette build bonks. oh, joy.
#opts_knit$set(progress=TRUE)
opts_knit$set(eval.after='fig.cap')
# for a package vignette, you do want to echo.
# opts_chunk$set(echo=FALSE,warning=FALSE,message=FALSE)
opts_chunk$set(warning=FALSE,message=FALSE)
#opts_chunk$set(results="asis")
opts_chunk$set(cache=TRUE,cache.path="cache/")

#opts_chunk$set(fig.path="figure/",dev=c("pdf","cairo_ps"))
opts_chunk$set(fig.path="man/figures/",dev=c("png"))
opts_chunk$set(fig.width=7,fig.height=6,dpi=100,out.width='700px',out.height='600px')

# doing this means that png files are made of figures;
# the savings is small, and it looks like shit:
#opts_chunk$set(fig.path="figure/",dev=c("png","pdf","cairo_ps"))
#opts_chunk$set(fig.width=4,fig.height=4)
# for figures? this is sweave-specific?
#opts_knit$set(eps=TRUE)

# this would be for figures:
#opts_chunk$set(out.width='.8\\textwidth')
# for text wrapping:
options(width=124,digits=2)
opts_chunk$set(size="small")
opts_chunk$set(tidy=TRUE,tidy.opts=list(width.cutoff=50,keep.blank.line=TRUE))
library(ggplot2)
library(mazealls)
library(dplyr)
library(moments)
library(microbenchmark)
# chicken and egg dept:
# [![CRAN](http://www.r-pkg.org/badges/version/mazealls)](http://cran.rstudio.com/package=mazealls) 
# [![Downloads](http://cranlogs.r-pkg.org/badges/mazealls?color=brightgreen)](http://www.r-pkg.org/pkg/mazealls)
# [![Total](http://cranlogs.r-pkg.org/badges/grand-total/mazealls?color=brightgreen)](http://www.r-pkg.org/pkg/mazealls)
#[![Downloads](http://cranlogs.r-pkg.org/badges/mazealls?color=green)](http://www.r-pkg.org/pkg/mazealls)
#[![Total](http://cranlogs.r-pkg.org/badges/grand-total/mazealls?color=green)](http://www.r-pkg.org/pkg/mazealls)
# think lifecycle badges: https://github.com/r-lib/usethis/issues/48
#from CRAN, 
# via CRAN:
#install.packages("mazealls")
```

# mazealls

[![Build Status](https://travis-ci.org/shabbychef/mazealls.png)](https://travis-ci.org/shabbychef/mazealls)
[![codecov.io](http://codecov.io/github/shabbychef/mazealls/coverage.svg?branch=master)](http://codecov.io/github/shabbychef/mazealls?branch=master)
[![CRAN](http://www.r-pkg.org/badges/version/mazealls)](https://cran.r-project.org/package=mazealls)

> *Sometimes magic is just someone spending more time on something than anyone else might reasonably expect.* -- Teller
	

Generate mazes recursively via Turtle graphics. 

-- Steven E. Pav, shabbychef@gmail.com

## Installation

This package can be installed 
via [drat](https://github.com/eddelbuettel/drat "drat"), or
from github:

```{r install,eval=FALSE,echo=TRUE}
# via drat:
if (require(drat)) {
    drat:::add("shabbychef")
    install.packages("mazealls")
}
# get snapshot from github (may be buggy)
if (require(devtools)) {
	install_github('shabbychef/mazealls')
}
```

# parallelogram maze

The simplest maze to generate recursively is a parallelogram. One can generate
a parallelogram maze by splitting the domain into two parts by an arbitrary
cut line with a hole in it, and then recursively creating mazes on both parts. 
Unlike some shapes, this method applies for arbitrary (integral) side lengths,
where by 'length' we mean in units of 'hallway widths', what we call the
`unit_len` in the API. Here is a simple parallelogram maze:

```{r para_maze,cache=TRUE,eval=TRUE,echo=TRUE,dpi=250,out.width='800px',out.height='600px',fig.keep='last'}
library(TurtleGraphics)
library(mazealls)
turtle_init(1000,1000)
turtle_up()
turtle_hide()
turtle_do({
	turtle_left(90)
	turtle_forward(distance=400)
	turtle_right(90)
	parallelogram_maze(angle=90,unit_len=10,width=75,height=55,method='uniform',
	 draw_boundary=TRUE)
})

```

# triangle maze

An equilateral triangle maze can be computed in a number of different ways:

  # Create four equilateral mazes with lines with holes between them. This
	only works if the side length of the original is a power of two.
	# Cut out a parallelogram and attach two equilateral triangles.
	Again only if the side length is a power of two.
	# Create an isosceles trapezoid maze, then stack an equilateral triangle
	on top of it. This only works if the side length is even.
	# Create a regular hexagonal maze and three equilateral mazes in the corners.
	This only works if the side length of the original triangle is divisible by
	three.
	# Shave off a single hallway and create an equilateral triangular maze
	of side length one less than the original.


I illustrate them here:

```{r eq_tri_uniform,cache=TRUE,eval=TRUE,echo=TRUE,dpi=250,out.width='800px',out.height='600px',fig.keep='last'}
library(TurtleGraphics)
library(mazealls)
# uniform method
turtle_init(1000,1000)
turtle_up()
turtle_hide()
turtle_do({
	turtle_left(90)
	turtle_forward(distance=300)
	turtle_right(90)
	eq_triangle_maze(depth=6,unit_len=12,method='uniform',draw_boundary=TRUE)
})
```

```{r eq_tri_stack,cache=TRUE,eval=TRUE,echo=TRUE,dpi=250,out.width='800px',out.height='600px',fig.keep='last'}
library(TurtleGraphics)
library(mazealls)
# stacked trapezoids
turtle_init(1000,1000)
turtle_up()
turtle_hide()
turtle_do({
	turtle_left(90)
	turtle_forward(distance=300)
	turtle_right(90)
	eq_triangle_maze(depth=6,unit_len=12,method='stack_trapezoids',draw_boundary=TRUE)
})
```

```{r eq_tri_four_tri,cache=TRUE,eval=TRUE,echo=TRUE,dpi=250,out.width='800px',out.height='600px',fig.keep='last'}
library(TurtleGraphics)
library(mazealls)
# four triangles
turtle_init(1000,1000)
turtle_up()
turtle_hide()
turtle_do({
	turtle_left(90)
	turtle_forward(distance=300)
	turtle_right(90)
	eq_triangle_maze(depth=6,unit_len=12,method='triangles',draw_boundary=TRUE)
})

```{r eq_tri_two_ears,cache=TRUE,eval=TRUE,echo=TRUE,dpi=250,out.width='800px',out.height='600px',fig.keep='last'}
library(TurtleGraphics)
library(mazealls)
# two ears
turtle_init(1000,1000)
turtle_up()
turtle_hide()
turtle_do({
	turtle_left(90)
	turtle_forward(distance=300)
	turtle_right(90)
	eq_triangle_maze(depth=6,unit_len=12,method='two_ears',draw_boundary=TRUE)
})
```

```{r eq_tri_hex_and_three,cache=TRUE,eval=TRUE,echo=TRUE,dpi=250,out.width='800px',out.height='600px',fig.keep='last'}
library(TurtleGraphics)
library(mazealls)
# hex and three
turtle_init(1000,1000)
turtle_up()
turtle_hide()
turtle_do({
	turtle_left(90)
	turtle_forward(distance=300)
	turtle_right(90)
	eq_triangle_maze(depth=log2(66),unit_len=12,method='hex_and_three',draw_boundary=TRUE)
})
```

```{r eq_tri_shave,cache=TRUE,eval=TRUE,echo=TRUE,dpi=250,out.width='800px',out.height='600px',fig.keep='last'}
library(TurtleGraphics)
library(mazealls)
# shave 
turtle_init(1000,1000)
turtle_up()
turtle_hide()
turtle_do({
	turtle_left(90)
	turtle_forward(distance=300)
	turtle_right(90)
	eq_triangle_maze(depth=log2(66),unit_len=12,method='shave',draw_boundary=TRUE)
})
```


```{r eq_tri_shave_all,cache=TRUE,eval=TRUE,echo=TRUE,dpi=250,out.width='800px',out.height='600px',fig.keep='last'}
library(TurtleGraphics)
library(mazealls)
# shave all
turtle_init(1000,1000)
turtle_up()
turtle_hide()
turtle_do({
	turtle_left(90)
	turtle_forward(distance=300)
	turtle_right(90)
	eq_triangle_maze(depth=log2(66),unit_len=12,method='shave_all',draw_boundary=TRUE)
})
```

